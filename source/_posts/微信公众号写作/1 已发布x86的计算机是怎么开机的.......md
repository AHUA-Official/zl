---
title: x86计算机是怎么开机的
date: 2025-01-16 10:00:00
tags: [计算机基础]
categories: [微信公众号]
---



摘要
讲解了x86计算机的开机流程

参考
https://www.ruanyifeng.com/blog/2013/02/booting.html
阮一峰的博客

Ver  2.0 好看排版版
动机
我每天都要给电脑开机，不管是我的个人电脑也好，还是我的各类开发板或者各种云服务器。每天都得看各种开机界面，还得经常重装系统看各种BIOS界面。开机总熟悉了吧，这些x86的计算机总熟悉了吧。

可是问题来了   我其实不知道这些x86的机器是咋来的，他们又是咋开机的。

所以这就是今天探讨的问题啦  ：  x86的计算机是怎么开机的?......

Intel  x86历史
MS-DOS（Microsoft  Disk    Operating   System）   是2000年前广泛用于x86架构的操作系统

绝大多数Linux发行版，如Ubuntu、Debian、Fedora、CentOS提供x86_64位的iso镜像

电脑下载软件   提供的exe文件有win_x86   win_x64    mac  的安装包

好 x86 咋来的？x86是什么？   我们先简单来看这些例子

x86的处理器历史
  1978年  因特尔生产了著名的16位8086处理器（16位寄存器，1mb physical address  space  ）
1982年      80826   引入保护模式（protected   model    支持虚拟内存  16mb physical address  space  ）
1985年，因特尔继摩托罗拉之后，第二个研制出32位的微处理器80386；就是IA-32（Intel   Architecture32-bit）  --  i386
1989年，因特尔推出80486处理器，具有浮点运算功能；
当初与因特尔竞争微处理器的摩托罗拉公司是以86开头的，如68000，68010，68020。
1993年，因特尔推出奔腾处理器（Pentium），不再以数字命名其产品；
后来在微处理器行业摩托罗拉没有竞争过因特尔，而Intel也不再以数字命名其产品，但是大家仍然习惯性的把因特尔的处理器称为X86系列，X作为通配符代替前面的数字，所以后来  基于相同指令集架构的处理器一般就都叫做x86系列啦    ，现在x86系列处理器已经是使用最广泛的处理器架构了，其他出名的架构还有  arm  等

x86_64 x64  和  AMD_64
基于32位cpu开发的操作系统就叫32位操作系统，因为目前x86架构在32位cpu的知名度，32位操作系统也通常被称为x86系统。  -->(带86的也不一定为32位处理器，只是因为这些带86的32位处理器很出名，叫的用的都比较多，最后也就习惯了)

但是32位操作系统在后面慢慢的性能不太够了   ，比如 32位系统只可以有效寻址4GB空间   管控4GB内存   在计算方面  32位计算也渐渐无法满足人们的需求了     所以Intel也在慢慢的从更好适配32位系统的处理器向更好支持64位操作系统的架构做转变了 （ps：当时市面上的友商也在紧锣密鼓的研发64位架构的处理器）， Intel的研发其实有2选择

向下兼容x86
完全重新设计指令集，不兼容x86
结果AMD领先，比Intel率先制造出了商用的兼容x86的CPU，AMD称之为AMD64，抢了64位PC的第一桶金，得到了用户的认同。

而Intel选择了设计一种不兼容x86的全新64位指令集，称之为IA-64，但是比amd晚了一步，而且IA-64也挺惨淡的，因为是全新设计的CPU，没有编译器，也不支持windows（微软把intel给忽悠了，承诺了会出安腾版windows server版，但是迟迟拿不出东西）。。。后来不得不在时机落后的情况下也开始支持AMD64的指令集，但是换了个名字，叫x86_64，表示是x86指令集的64扩展。（x64也基本就是x86_64啦）

也就是说实际上，x86_64,x64,AMD64基本上是同一个东西，我们现在用的intel/amd的桌面级CPU基本上都是x86_64架构的

IBM    PC &BIOS
我们再回到MS-DOS

MS -DOS 是微软给IBMPC开发的cli OS  for   Intel   x86处理器（最早一代在intel 8086处理器）

在后来  IBM PC   事实上成为了 PC的标准    MS-DOS  事实上也成为了 PC的标准OS

所以后来的PC市场   基本上也就是顺着这两家的技术标准一路发展过来的

在1981年     BIOS问世 （Basic   Input Output  System ）

BIOS是一种firmware   存储在主板芯片上的固件   也就是说   你用谁家的电脑  就用的是谁家的BIOS    BIOS是完全预装好的    而且BIOS和硬件的关系很大   基本不存在我华硕的主板可以换成微星的BIOS启动  （更何况  绝大多数的BIOS是直接ROM启动的  刷不掉）

BIOS是为了在PC开机的时候初始化硬件的固件接口 并引导OS启动的引导程序

QA：    那我在装系统的时候  咋只看见两种启动选项捏？LEGACY  or   UEFI     没有看到BIOS启动的选项呀？

（其实BIOS的启动方式我们现在也可以看到

很多我们装系统的时候   选择加载选项LEGACY 启动

这个就是传统的 BIOS启动

那为什么不直接写BIOS启动呢。而是让你选择LEGACY  or   UEFI 呢？ ）

其实是因为

UEFI也是一种引导操作系统初始化和加载的固件
在21世纪20年代    现在绝大部分的处理器和操作系统支持UEFI启动   不过为了让老的基于BIOS的操作系统在支持UEFI的处理器上正常启动，好心的厂商提供了Leagacy BIOS  兼容模式（也叫做 CSM   Compatibility  Support  Model ）     来兼容不支持UEFI的OS正常启动
那问题来了   UEFI是啥？  为啥现在的大多数处理器和OS都倒向了支持UEFI呢？大家继续往下看吧

UEFI  &   BIOS
那UEFI启动呢 ？   BIOS固然是经久不息的启动流程   可是时代也是在发展的

2012年  win8发布   微软强制要求  新硬件必须支持UEFI启动了    不然就不给许可证

那么UEFI是什么呢？

UEFI也是也是存储在主板芯片上的固件 UEFI是怎么来的呢？

最开始是INTEL开发了EFI（Extensible  Firmware  Intreface）

后来好多个公司大家一起开发  就叫做 UEFI了  Extensible  Firmware  Intreface）

相对于传统的BIOS   UEFI引进了那些改进呢？

UEFI  支持     GUID   Partition  Table （GPT分区方案支持更大磁盘分区 更多分区（最大可达128） 传统BIOS的MBR只有2TB   4 ）

UEFI支持同时加载多个主分区

UEFI支持安全启动

BIOS流程
但是说老实话    MBR又是啥   我都不知道MBR是啥  你就告诉我 UEFI支持的GPT更好了  这有点太快了吧

停停停     先别急喵   这就来告诉你   MBR是怎么来的喵    要说这个东西   咱得先扯一下 BIOS开机的流程喵

POST Power On  Self  Test   电源自检
BIOS程序首先检查，计算机硬件能否满足运行的基本条件，这叫做"硬件自检"（Power-On Self-Test）。如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止。如果没有问题，屏幕就会显示出CPU、内存、硬盘的信息

硬件初始化
POST检查完毕后，BIOS从CMOS存储器中获取系统配置数据，包括时间、启动顺序等，这些数据即使断电也能保留。CMOS读取后，BIOS分配硬件资源，如为硬盘、显卡分配特定的系统资源，以防止冲突，为系统稳定性打下基础。
同时，BIOS加载基本硬件驱动，比如让BIOS能读取硬盘上操作系统启动文件的磁盘控制器驱动，硬件初始化的核心是创建一个简约运行环境，保证能加载操作系统等复杂软件。这涉及内存映射设定、外设激活及CPU模式调整等，为后面操作系统加载做准备。

值得注意的是   这个时候往往会有一个启动顺序的选项需要我们配置

通过设置BIOS的Boot Sequence来决定设备的启动顺序。BIOS按照启动顺序，把控制器移交给排名第一的启动设备。比如，我们有两块硬盘，硬盘A排名第一  硬盘B第二 还有 IPXE第三  ，那么BIOS就会加载硬盘A的第一个扇区中的代码到内存中，然后执行它，这样就把控制权交给了硬盘A（硬盘A里面就有关于我们想要安装启动的操作系统信息了哦~    在这之后   就是引导加载操作系统（bootloader）的任务了   我们常说的   MBR磁盘分区 也就水灵灵的登场啦~）

MBR--    读取第一扇区信息
BIOS按照"启动顺序"，把控制权转交给排在第一位的储存设备的第一个扇区    也就是前512个字节

这512个字节的最后两个字节是0x55和0xAA，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给"启动顺序"中的下一个设备

这512个字节，就叫做"主引导记录"（Master boot record，缩写为MBR）

这512个字节  又写了啥东西呀？   可以分成三部分

前   446 (1 - 446)** bootloader code **
代码区，BIOS就是把它加载到内存中把控制器移交给它，该代码会知道如何去启动操作系统

**中   64   (**447 - 510)  partition   table  分区表
硬盘的分区表，保存了这个硬盘的分区信息，比如有几个分区，每个分区从哪里到哪里

分区表只占用了64字节，而每个分区的无数据需要占据16个字节，所以一个硬盘最多可以分成4个区。我们来看一下每个分区的16字节元数据

第1字节：如果为0x80，就表示该主分区是激活分区，从这个分区启动系统。四个主分区里面只能有一个是激活的
第2 - 4字节：该分区第一个扇区的物理位置（柱面、磁头、扇区号等等）
第5字节：主分区类型
第6-8个字节：主分区最后一个扇区的物理位置
第9-12字节：该主分区第一个扇区的逻辑地址
第13-16字节：该分区的扇区总数
最后的四个字节（"主分区的扇区总数"），决定了这个主分区的长度。也就是说，一个主分区的扇区总数最多不超过2的32次方。如果每个扇区为512个字节，就意味着单个分区最大不超过2TB。再考虑到扇区的逻辑地址也是32位，所以单个硬盘可利用的空间最大也不超过2TB。如果想使用更大的硬盘，只有2个方法：一是提高每个扇区的字节数，二是增加扇区总数

后    2 位   validationcode     0xAA55
是 主引导记录签名

MBR  --   载入内存   执行 1阶段bootloader  code 定位VBR 硬盘启动   执行2阶段bootloader
这个时候我们去执行MBR中存储的bootloader  也就是第一部分的bootloader  code       这一段引导加载程序会定位并去加载到VBR    把计算机的控制权就要从MBR转交给硬盘的某个分区里面的VBR了，这里又分成三种情况

1 卷引导记录（VBR）

四个主分区里面，只有一个是激活的。计算机会读取激活分区的第一个扇区，叫做"卷引导记录"（Volume boot record，缩写为VBR）。

"卷引导记录"的主要作用是，告诉计算机，操作系统在这个分区里的位置。然后，计算机就会加载操作系统了。

假设在一块硬盘的两个主分区中分别安装了windows与linux系统，如果要启动哪个系统，则必须把这个系统的分区设置为活动分区。

2 扩展分区和逻辑分区

随着硬盘越来越大，四个主分区已经不够了，需要更多的分区。但是，分区表只有四项，因此规定有且仅有一个区可以被定义成"扩展分区"（Extended partition）。

所谓"扩展分区"，就是指这个区里面又分成多个区。这种分区里面的分区，就叫做"逻辑分区"（logical partition）。

计算机先读取扩展分区的第一个扇区，叫做"扩展引导记录"（Extended boot record，缩写为EBR）。它里面也包含一张64字节的分区表，但是最多只有两项（也就是两个逻辑分区）。

计算机接着读取第二个逻辑分区的第一个扇区，再从里面的分区表中找到第三个逻辑分区的位置，以此类推，直到某个逻辑分区的分区表只包含它自身为止（即只有一个分区项）。因此，扩展分区可以包含无数个逻辑分区。

但是，似乎很少通过这种方式启动操作系统。如果操作系统确实安装在扩展分区，一般采用下一种方式启动。

3 启动管理器

这种情况和卷引导记录有些相似，计算机读取"主引导记录"前面446字节的机器码之后，把控制器交换给活动分区。但是在活动分区下的操作系统中，还安装了活动管理器。即在启动活动分区的操作系统时，最先执行的是该操作系统的启动管理器。假设在另一个分区中还安装了其他的操作系统，那么我们可以在这个启动管理器中把另一个操作系统加进来，由用户选择启动哪一个操作系统。

Windows环境下，最常用的就是Windows Boot Loader；Linux环境中，目前最流行的启动管理器是GRUB GRand Unified Bootloader（大一统引导程序）https://en.wikipedia.org/wiki/GNU_GRUB 的首字母缩写。

kernel   Init
控制权转交给操作系统后，操作系统的内核首先被载入内存。

以Linux系统为例，先载入/boot目录下面的kernel。内核加载成功后，第一个运行的程序是/sbin/init。它根据配置文件（Debian系统是/etc/initab）产生init进程。这是Linux启动后的第一个进程，pid进程编号为1，其他进程都是它的后代。

然后，init线程加载系统的各个模块，比如窗口程序和网络程序，直至执行/bin/login程序，跳出登录界面，等待用户输入用户名和密码。

UEFI （Why  and   开机流程）
再简单总结一下为什么使用大家逐渐转向UEFI的原因吧

BIOS只能在16位real   mode下运行 地址空间仅1MB
磁盘分区限制
引导加载限制
不支持安全启动
UEFI启动流程

POST电源自检
硬件初始化
**UEFI读取 NVRAM中的boot  entries **
**UEFI 从 GPT磁盘上的ESP（EFI  System  Parttition  ）查找EFI application （通常是boot loader）  根据 boot  entries    选择EFI application 启动      EFI application 加载OS  kernel **
如果   enable    ecure boot  （安全启动）  引导过程中会对EFI 进行  digital    signatre 验证  防止恶意软件
图片
说老实话  在kernel init 这个过程里面   还涉及到复杂的一些列问题   比如内核是如何装载解压自初始化的   以及systemd是怎么起作用的   这个地方我不懂   就留待以后再发公众号探讨吧

好了 ，今天就写到这里  大家再见咯！
